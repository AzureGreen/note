# 浏览常见问题整理

## cpp

1. 为什么空类大小为1?

   编译器插进去了一个char，保证还class实例化的对象配置独立的地址





## 数据库

1. b树，b+树

    为什么数据库，文件系统使用b树，b+树，不同平衡树？

    - 文件系统等需要频繁读写磁盘，树的高度越深，需要读写磁盘的次数越多，相比于查找速度更快的平衡树，b树的高度更低，磁盘读写所需时间开销更小
    - 磁盘预读特性，磁盘预读过程会顺序读取，一次IO读取一个节点，邻近节点也会被顺序预先载入。

    为什么大部分使用b+树？

    - b+树非叶子节点不做数据存储，仅做索引，所有数据都存放在叶子节点，b树每个索引节点都会有数据域，为了把数据读取出来，在每层遍历时会增大磁盘IO次数，影响性能。
    - b+树的数据域都在叶子节点，而且通过一个链表指针连接起来，这样可以方便区间访问，适用于**范围查询**频繁使用的数据库。

2. 索引

   数据库索引：数据库管理系统中一个排序的数据结构，协助快速查询，更新数据库表中数据。

   索引的好处？

   - 加快查找速度，不用全表扫描

   - 将随机IO变成顺序IO（b+树索引有序，将相邻的数据存储在一起）

   聚集索引？

   - 索引中键值的逻辑顺序决定了表中相应行的物理顺序。
   - 由于聚集索引规定数据在表中的物理存储顺序，因此一个表只能包含一个聚集索引。

   非聚集索引

   - 索引中的索引逻辑顺序与在磁盘上行的物理存储顺序不同。

3. 事务的特点

   ACID：原子性，一致性，隔离性，持久性


4. 一致性问题

   脏读，不可重读，幻影读

5. 隔离级别 各自实现 优缺点

   - 未提交读，提交读，可重复读，可串行化
   - 分别用行级表级读写锁实现上述级别
   - 分别解决了一致性的什么问题，还有什么问题没解决

6. mvcc和next-key-locks

   - mvcc多版本控制，针对的是数据**行**，事务对数据行的操作会通过链表机制记录在`undo`日志中，	针对读操作直接采取`快照读`，避免加锁，针对修改操作用`当前读`，需要加锁。
   - next-key-locks是innodb的锁实现，它不仅锁定一个记录上的索引，同时锁定索引之间的间隙。
   -  在可重复读（REPEATABLE READ）隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题 

7. inodb myisam





## 网络
1. tcp udp区别

   突出tcp面向连接的，可靠的服务，以及为了实现可靠的一些机制，相应udp是无连接，不可靠，最大可能交付的服务

   [TCP与UDP区别](network/network.md#TCP与UDP区别)

2. tcp可靠机制

   超时重传：超时时间内为收到确认，则重传报文

   滑动窗口，流量控制：控制发送方的发送速率，保证接收方接的过来

   拥塞控制：控制发送方的发送速率，保证网络可以承载那么多数据

   [CS-Notes/notes/计算机网络-传输层](https://github.com/CyC2018/CS-Notes/blob/master/notes/计算机网络 - 传输层.md#tcp-可靠传输)

3. 浏览器访问网页发生了什么

   [终极之问](network/network.md#终极之问)

4. https相关问题

   [HTTPS相关](network/network.md#HTTPS相关)

5. put与post的区别，get与post的区别

   1. put与post

      - put是幂等的，多次执行结果一样，也就是后面请求会覆盖前面的请求

      - post不是幂等的，

   2. get与post
      - 参数：get通过url传参，只能是ASCII；post在body中，支持标准字符集；
      - 可缓存：get请求会被浏览器主动cache；post需要手动设置才cache；
      - 安全：get是只读请求，不改变服务器状态，安全；post会传输实体，可能修改数据库，因此服务器状态改变，不安全；
      - 幂等性：get是；post不是

6. UDP怎么构建可靠通信

   参考QUIC

7. http缓存机制

   参考下面的缓存部分，以及终极之问

## 操作系统

进程线程的关系

进程通信

线程调度 线程生命周期

进程fork子进程，内存占用情况(写时复制)



## io
非阻塞io与阻塞io

## 缓存
- http请求头和响应头跟缓存有关的字段

  - **强缓存**：Expires，Cache-control

  1. Expires：GMT时间，告知浏览器在此期间内，可信任并使用该文件缓存，即浏览器下次请求时间只要小于该时间，可直接从缓存中获取数据，不再向服务器请求。
  2. Cache-control：private，public，no-cache，max-age，no-store
     - private：客户端可缓存
     - public：客户端和代理服务器均可缓存
     - max-age：缓存存储的最大周期，http/1.1起取代Expires
     - no-cache：每次请求浏览器需向服务器发送请求，让服务器判断缓存的有效性
     - no-store：不缓存

  - **对比缓存**：Last-Modified，Etag
  1. Last-Modified：GMT时间，告知浏览器资源的最后修改时间
  
     - If-Modified-Since：比较资源最后更新时间是否一致 （304）
     - If-Unmodified-Since：比较资源最后更新时间是否不一致 （412）
  
  2. Etag：文件实体的签名，资源唯一标识符，文件发生变化，Etag值也会变化
  
     - If-Match：比较Etag是否一致 （304）
     - If-None-Match：比较Etag是否不一致  （412）
  
     > Etag比Last-Modified更加严格
     >
     > Last-Modified检测粒度是秒级
     >
     > 文件被修改，但内容并未修改，Last-Modified会改变，但Etag并不会。
     
     对比缓存的定义：服务器对比判断文件是否修改，告诉浏览器是否可以使用本地缓存，如果可以使用，服务器会返回浏览器304，否则完成一次正常的200请求。
  
- 浏览器缓存的工作流程

  1. 判断浏览器是否缓存，若没有则向服务器请求资源，若有走2；
  2. 判断缓存是否有效（强缓存），若有则使用本地资源，否则走3；
  3. 向服务器请求检测资源是否更新，若没有则仅返回304，浏览器使用本地资源，否则服务器返回200并返回请求资源。

  > 参考：[彻底理解浏览器的缓存机制](https://juejin.im/entry/5ad86c16f265da505a77dca4)

- 缓存穿透

  查询一个一定不存在的数据，导致缓存一定产生缺失，从而会向后端数据库查询，从而缓存失效。如果是恶意攻击，将会导致流量过大，后台数据库扛不住，最后崩溃。

  1. 通过布隆过滤器，把所有可能存在的数据全保存起来，这样就可以过来不存在的访问。
  2. 另一种简单方法是，直接将该次请求保存在缓存中，对应value为null，过期时间设短点。

- 缓存雪崩

  设置缓存过期时间相同，导致缓存在某一时刻有大量文件同时失效，因而请求将全部转发到后端数据库上，导致数据库瞬间访问压力过大从而雪崩。

  1. 简单的处理就是设置缓存失效时间分散开。

- 缓存击穿

  同时有大量请求同一个文件，但是该文件刚好缺失或失效了，这时大量请求都会去走数据库请求，从而导致数据库又扛不住了，崩溃。

  1. 针对这个问题，采用互斥锁解决。因为这类请求是多线程请求同一个资源，因为第1个线程请求时，加锁，等第一个线程从数据库拉取回数据，缓存下来后，解锁，这样其他线程的请求就可以直接读缓存了。

  > 参考：[关于【缓存穿透、缓存击穿、缓存雪崩、热点数据失效】问题的解决方案](https://juejin.im/post/5c9a67ac6fb9a070cb24bf34)

## 分布式

一致性哈希



分布式锁



## 服务 
rpc