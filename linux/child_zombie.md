## 孤儿进程与僵尸进程

### 孤儿进程

父进程退出了，而子进程仍在运行，这时子进程就成了孤儿进程。孤儿进程会有init进程托管，在子进程执行结束，会成功释放资源，因为子进程此时的父进程就是init进程了。

### 僵尸进程

- 子进程在结束退出后，会释放进程占用的资源，但是内核仍旧保存了该子进程的一定量信息（进程ID，终止状态等），等待父进程去处理。而子进程在退出时会给父进程发送`SIGCHID`信号，父进程通过`wait`或者`waitpid`可以接收到这个信号，从而处理子进程遗留的信息。

- 如果父进程没有处理子进程那些遗留的信息，则子进程的这些资源无法得到释放，占用进程id，而进程id是有限的，这样会导致进程id无法重用，影响新进程的创建。

#### 处理僵尸进程

将其父进程杀死，此时僵尸进程将全变成孤儿进程，被init托管，从而其资源会得以释放。

#### 避免僵尸进程

1.  通过`signal(SIGCHLD, SIG_IGN)`通知内核对子进程的结束不关心 ；
2.  父进程调用`wait/waitpid`等函数等待子进程结束 ;（ WNOHANG 可以非阻塞）
3. 父进程可以通过signal注册信号处理函数，在信号处理函数调用`wait/waitpid`等待子进程退出 ;
4. 通过两次`fork`。父进程fork出子进程后通过`wait/waitpid`等待子进程结束，然后子进程`fork`出孙进程去做原先实际的子进程功能，然后子进程直接退出，这时孙进程就变成孤儿进程由init托管。

参考：[linux下的僵尸进程处理SIGCHLD信号](https://www.cnblogs.com/wuchanming/p/4020463.html)