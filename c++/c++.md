### 1. 基础知识

#### static 关键字

修饰静态变量，静态数据存储在全局（静态）存储区，而非栈区，DATA段(全局初始化区)和BSS段(全局未初始化区)，静态数据要求初始化，若未初始化则默认初始化0（BSS段），总体来说，延长了局部变量生命周期。

C++要求类静态成员变量必须在程序一开始就初始化，且仅有一次初始化机会

- static修饰的类变量和类方法为所有类对象实例共享的在静态资源。

- static修饰的全局变量作用域仅限于当前文件，其他文件不可extern声明使用。
- static修饰的局部变量作用域为局部作用域，离开定义的代码块，作用域结束。
  - 最简单完美的单例模式就是基于此，instance函数里定义了静态对象，返回该实例的引用即可。

#### 右值与右值引用

> 详细分析参考：[c++11左值右值及引用](lvalue_rvalue.md)

- 右值：字面量或表达式求值产生的临时对象。
- 右值引用：c++11开始启动的概念，顾名思义，是对右值的引用，如此一来右值引用接管了临时对象的所有资源，且延长了其生命周期。
- 移动语义：通过`std::move`强行转换成右值引用，在拷贝或赋值时，走移动构造或移动赋值从而仅仅只是搬移资源而不是复制，节省下时间与空间开销。

#### new和malloc

> 参考： [细说new与malloc的10点区别](https://www.cnblogs.com/qg-whz/p/5140930.html)
>
> new：1. operator new() 申请内存；2. 构造函数；3.返回指针

|         特征         |                          new/delete                          |             malloc/free              |
| :------------------: | :----------------------------------------------------------: | :----------------------------------: |
|    分配内存的位置    |                          自由存储区                          |                  堆                  |
| 内存分配成功的返回值 |                    完整类型指针（更安全）                    |                void*                 |
|  构造函数与析构函数  |                             调用                             |                不调用                |
| 内存分配失败的返回值 |                   默认抛出异常(bad_alloc)                    |                 NULL                 |
|     分配内存不足     | 用户可指定处理函数或重新制定分配器<br/>set_new_handler & set_handler |       无法通过用户代码进行处理       |
|    分配内存的大小    |                   由编译器根据类型计算得出                   |          必须显式指定字节数          |
|       处理数组       |                   有处理数组的new版本new[]                   | 需要用户计算数组的大小后进行内存分配 |
|   已分配内存的扩充   |                        无法直观地处理                        |         使用realloc简单完成          |
|     是否相互调用     |            可以，看具体的operator new/delete实现             |             不可调用new              |
|       函数重载       |                  允许，重载的是operator new                  |                不允许                |

#### operator new和placement new

> 参考：[C++中的new、operator new与placement new](https://www.cnblogs.com/luxiaoxun/archive/2012/08/10/2631812.html)

- new operator是操作符，而operator new是函数，用于new的第一步申请内存，可被重载。
- placement new就是operator new重载版本的其中之一，并不分配内存，只是返回已分配好内存的一个指针，销毁资源需要显示调用析构函数。

#### 杂项

##### 头文件包含

- <>：直接在系统指定目录下查找目标头文件。`/usr/include` >`/usr/local/include` > `usr/lib/gcc-xxx/xxx` 
- “”：首先在源文件所在目录下查找指定头文件，然后再去系统指定目录查找。

##### 类成员变量初始化

1. 初始化顺序：声明时赋值 > 初始化列表赋值 > 构造函数赋值 （`>`表示早于）
2. 初始化列表初始化类成员初始化顺序由声明顺序决定，构造函数初始化顺序由在构造函数内的赋值顺序决定。
3. 考虑到继承：基类静态成员变量 > 子类静态成员变量 > 基类成员变量 > 子类成员变量。

##### 重载/重写/隐藏

- 函数重载：编译时多态，函数名相同，通过不同的参数列表调用对应的函数
- 函数重写：运行时多态，子类重写基类的虚函数，体现出多态性。
- 函数隐藏：子类与基类函数名相同，参数列表不同，不论是否有`virtual`关键字，基类函数会被隐藏；子类与基类函数名相同，且参数列表相同，基类没有`virtual`关键字，基类函数会被隐藏。

##### 模板特化与偏特化

```c++
// 模板声明
template <typename T1, typename T2>
class A<T1, T2> {
    T1 v1_;
    T2 v2_;
};
// 特化
template <>
class A<int, double> {
    int v1_;
    double v2_;
};
// 偏特化
template <typename T2>
class A<int, T2> {
    int v1_;
    T2 v2_;
};
```

特化就是直接给定“模板实参”列表，而偏特化则是没有给定全部的“模板实参”。

模板类可特化与偏特化，模板函数只能特化。

### 2.虚函数

> 更详细分析参考：[虚表分析](virtual_table.md)

#### 虚函数与虚表

```c++
virtual void func() {}
```

带有`virtual`关键字的类成员函数即为虚函数，在创建声明中有虚函数的类对象时，在构造的过程中会生成一张保存了虚函数地址的表，称为**虚表（vtable）**，虚表的首地址保存在该对象首地址里，也就是***this**的第一个成员。

1. 针对没有继承关系的基类的虚表按声明顺序保存着虚函数的地址

2. 针对单继承关系的子类的虚表首先保存父类的虚函数地址，其中被子类覆盖的虚函数会替换为子类虚函数地址，接着再保存子类自己的虚函数地址。

3. 针对多继承关系的子类会有**多张**虚表，其中第一张虚表保存第一个基类与子类自己的虚函数地址，规则与2相同，剩下多少个基类就还有多少张虚表，且每张虚表仅保存基类的虚函数地址，规则与2相同。

#### 多态

主要关注运行时多态，函数重载为编译时多态。

运行时多态：通过虚函数实现，函数的地址调用在编译器期间无法确定，需要在运行时才能确定。多态实现了接口重用，即一个接口，多种方法，通过统一的接口调用到适应各自对象的实现方法。

```c++
class Base {
public:
    Base() {}
    virtual ~Base() {}
    virtual void Func() {}
};

class Derived: public Base {
public:
    Derived() {}
    ~Derived() {}
    void Func() {}	// override
};
Base *base = new Derived();
```

类似于上述代码是常见的多态用法，声明基类指针绑定子类对象，调用虚方法时根据虚表去查找该调用父类方法还是子类方法。

> 比较常用的比如工厂模式

#### 虚继承与虚基类

```c++
class Derived: virtual public VBase {}
```

在继承时加上`virtual`关键字则表明为虚继承关系，用于解决重复继承产生的存储空间浪费与二义性问题。在虚继承时会出现虚基类表概念。

虚继承的内存结构与普通的多态继承不太一样，虚基表的内容也不同。

this指针对应内存首成员是子类自己的虚表指针，且**仅**保存了自己**独有**的虚函数地址，此后是**虚基类表**地址，然后保存子类自己的成员变量。虚基类表存放的均是**偏移**，按虚继承顺序分别存放子类相对于虚基类表的偏移，第一个虚继承基类相对虚基类表的偏移......以此类推。通过偏移可以找到对应的对象地址，对象地址分别按顺序保存着基类的虚表地址，以及基类的成员变量，其中基类的虚函数地址会被子类重写的给覆盖。

> 虚继承可以用来解决“菱形继承”问题。详细参考[虚表分析](virtual_table.md)，最后基类的虚函数表会合并在一起。

#### 虚析构函数

基类虚构函数不加`virtual`关键字，多态里面在析构时将仅析构基类，不会调用子类的析构函数，导致资源没有释放。

> Q：为什么不加`virtual`关键字的析构函数无法完成子类析构？
>
> A：因为在构造子类时，基类资源先构造，子类资源后构造，在内存中结构为基类成员在前，子类成员在后。故转换成基类指针后（相当于**强制类型转换**），就被截断了，在此后析构时也只能调用基类的析构函数。
>
> Q：为什么加`virtual`关键字的析构函数可以完成子类资源析构？
>
> A：在基类析构函数声明为虚函数后，在构造时会**建立虚函数表**，在虚表里子类的析构函数地址将取代基类析构函数地址，故此后析构函数将会**走子类的析构函数**，子类的析构函数在完成自己的析构工作后会自然调用基类的析构，故完成资源释放工作。
>
> (在vs中调试汇编码可以发现以上原理)

另外并不是所有类的析构函数均需要声明为虚函数，因为定义了虚函数，类对象会多了一个存放虚函数地址的**虚表**，从而增加了存储空间开销。故当有需要的时候：类作为基类才将析构函数声明为虚函数。

#### 纯虚函数与抽象类

```c++
class Base {
	virtual void func() = 0;
};
```

这样声明了一个纯虚函数`func`，相应的`Base`就成为了一个**抽象类**，抽象类类似于`Java`中的接口，不能实例化对象，必须由子类继承并覆盖纯虚函数。

- 纯虚函数没有定义体，但是是可以定义的。

- 析构函数可以是纯虚函数，但是必须有定义体，因为子类会隐式调用父类析构函数。

#### 构造函数为虚函数？

构造函数不允许为虚函数，也没有必要。

- 存储与实现：虚函数的调用需要虚表，而虚表是在构造阶段生成好的，也就是说对象尚未构建好，内存空间没有分配好，自然虚表不存在，自然无法调用虚函数，自然构造函数无法是虚函数，相互违背。
- 使用：虚函数的存在使得多态成为可能，而构造是一件确定的事情，且是创建对象时自动调用的，没有多态的必要。

#### 构造函数调用虚函数？

按照构造的顺序，构造函数先完成虚表的初始化工作，然后开始执行函数体内容，故调用的虚函数来自自己本身或者基类，而不会是之后的派生类重写的虚函数。

### 3.智能指针

智能指针是对原始指针的`RAII`封装，通过类对象接管原始指针，在析构时完成对内存资源的释放，避免内存泄漏。

- `unique_ptr`：同一时刻，由`unique_ptr`管理的资源只被一个指针**独占**，当离开其作用域时，指针指向的内存资源自动释放。可以**移动**构造与**移动**赋值，也就是只能转让所有权（右值），不可拷贝。

- `shared_ptr`：带有**强引用计数**的智能指针，代表当前有多少个`shared_ptr`对象保存了该指针，每多一个对象指针该指针，引用计数加一，当离开其作用域时，引用计数减一，直到引用计数为0，则释放内存资源。

  - 建议使用 `make_shared` 创建`shared_ptr`对象，因为其内存空间和因其计数的空间是同时分配，而使用new 需要两次内存分配的开销。
  - 默认析构函数调用`delete`析构资源，`c++17`之前如果指针指向的是一组对象，则需要自定义`delete functor`，且无法使用`make_shared`。

  ```c++
  shared_ptr<int> p(new int[5], [](int *p) { delete[] p; });
  ```

  - 避免用裸指针去创建`shared_ptr`，否者会出现多个`shared_ptr`对象分别对应同一块内存，但是分别引用计数的，当一个对象销毁跟着内存资源也销毁，但是其他对象仍旧引用这那块`null`内存，接下来的操作可能会引发异常。

- `weak_ptr`：作为`shared_ptr`的**弱引用**版本，可以共享`shared_ptr`持有的资源，但不包含也不可访问`shared_ptr`的资源。`weak_ptr`通过`shared_ptr`创建，但是对`shared_ptr`的强引用计数没有影响。

  - `weak_ptr`可通过`expired()`判断指向的资源是否有效，即是否还有`shared_ptr`的强引用。
  
  - `weak_ptr`可通过`use-count()`获取强引用计数。
  
  - `weak_ptr`可通过`lock()`获得`shared_ptr`，从而可以访问指向的内存资源。
  
  > 利用`weak_ptr`以及以上方法可以解决**循环引用**导致最后资源没有释放干净的情况。
  >
  > 循环引用：两个对象分别有个成员变量为另一个对象的shared_ptr对象，这样会造成两者相互等待析构才会释放资源的局面（就像死锁了一样），导致资源泄漏。
  >
  > 解决方案：将原先shared_ptr对象换成weak_ptr对象，需要使用原始指针时将weak_ptr转成shared_ptr即可。

Addition：手动实现简易版`shared_ptr`，代码编写详见[MySharedPtr](shared_ptr/main.cc)

### 4. STL相关

#### 内存配置器 allocator

内存配置器是`stl`超重要的部分，负责完成所有容器的**内存配置与释放**，以及**对象的构造与析构**工作。

一般讨论的是特殊配置器：`std::alloc` ，其分为两层配置器

- 第一层配置器：只是对系统调用`malloc`，`realloc`，`free`的简单封装，加上对于分配失败后的异常处理。
- 第二层配置器：在第一层配置器的基础上考虑的**内存碎片化**的问题，内置轻量级的**内存池**以及**16个自由链表(free-list)**，针对内存块**小于128字节**的申请，直接由内存池管理，大于128字节的内存块申请转交给第一层配置器。

##### SGI STL 内存池的实现

- *free-list*

  第二层配置器分配小于128字节内存为8的倍数，因此其维护了16个*free-lists*，每个链表管理的内存大小分别为8,16,24......120,128字节的小块内存。

  在申请内存时，如果对应区块的 *free-list* 为空，则会一次性从内存池申请一大块内存（20个新区块大小）（refill），加入到对应的 *free-list* 中，如果下次还有相同大小的内存**请求**，则直接从*free-list* 中**分配**。相应的，如果有内存**释放**了，则由 *free-list* **回收**到对应大小区块里。

  *free-list* 的node定义为一个联合体，可以简单理解为其用链表维护的每个内存区块前4/8字节保存了下一个内存区块的地址，这样并没有额外使用内存去记录链表，如此一来既没有浪费内存，而且形成了链表结构。

- *memory pool*

  内存池用于一次性批量申请内存区块大小的内存，在下次 *free-list* 有内存需求时可以直接分配内存，若内存池也不够用了，则会调用 `malloc` 从堆上申请大块内存再给 *free-list* 配置，总之就是减少因小区块而带来的系统额外负担（系统调用，记录内存块信息等）

#### 迭代器 iterator

#### 容器 container

- 线性：
  - *vector*：连续内存空间的数据结构，常用作数组功能，可随机访问。后插复杂度常数级，前插需要整体后移成员，复杂度为O(n)。在容量不够时会自动扩容，一般是重新申请两倍目前大小的内存空间，将原始值复制到新内存，然后释放原始内存空间。在clear()函数调用后不会真的清理内存，而是设置size为0。
  - *list*：双向链表，不支持随机访问。
  - *deque*：由不连续内存空间组成的线性数据结构，各块内存空间由一个map线性映射，从而逻辑上提供了线性访问的支持。可随机访问，同时支持前插与后插，且复杂度均为常数。
  - **适配器 adapter**：利用基本容器作为自己的底层容器，适配它以实现自己特定的功能。
    - *queue*：先进先出队列
    - *stack*：后进先出栈
    - *priority_queue*：优先队列/堆 根据比较规则实现最大堆或最小堆。
  
- 非线性：
  - *unordered_set/unordered_map*：底层实现为hash结构，常用于快速映射，查找复杂度平均为O(1)，容量不够用时需要`rehash`，即扩大hash索引的大小。
  
  - *set/map/multiset/multimap*：底层实现为`rbtree`，自带良好的排序结构，查找复杂度O(log(n))
  
    > 红黑树的性质：1.节点非黑即红；2.根是黑色；3.所有叶子都是黑色；4.红色节点必须有两个黑色子节点（即从根到叶子的路径上不能出现两个连续红色节点）；5.任意节点到每个叶子节点的简单路径包含相同数据的黑色节点。

#### 仿函数 functional

```c++
class Cmp {
public:
    bool operator()(int lhs, int rhs) {
        return lhs < rhs;
    }
};
```

在类中重载了`()`运算符，则该类对象可以像函数一样调用。例如上例`Cmp(1, 2)`就可以直接当做函数调用。

- 仿函数与普通函数的区别：仿函数是类，可以通过成员变量保存中间状态，而普通函数只能通过全局变量或者`static`变量完成。此外，通过仿函数类可以创建不同状态的实体，相当于是两个函数了，这也是普通函数做不到的。





### 参考资料

[C++11 智能指针]( https://www.jianshu.com/p/e4919f1c3a28 )

[深入理解STL源码(1) 空间配置器(allocator)]( http://ibillxia.github.io/blog/2014/06/13/stl-source-insight-1-memory-allocator/ )