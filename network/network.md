# 计算机网络

## TCP相关

TCP（传输控制协议）是面向连接的协议，提供可靠的网络连接服务，建立连接时会有三次握手，释放连接时会有四次挥手，以此保证连接的可靠性。

### 1. TCP三次握手

<img src='tcp_handshake.png' width=70% />

#### 流程

1. 在发起连接之前，服务端B上线，且处于`LISTEN`（监听状态），等待客户端的连接请求；
2. 客户端A主动发起连接请求报文（SYN），首部中<font color='red'>同步位SYN=1，确认位ACK=0，初始序号为seq=x</font>（SYN报文段不能携带数据），发送完成后，A将进入`SYN_SENT`（同步已发送状态）；
3. 服务端B收到来自客户端的请求报文后，决定是否连接，若同意建立连接，则向客户端发送链接确认报文（SYN+ACK），首部中<font color='red'>同步位SYN=1，确认位ACK=1，初始序号为seq=y，确认号为ack=x+1</font>（SYN报文段不能携带数据），发送完成后，B将进入`SYN_RCVD`（同步收到状态）；
4. 客户端A收到来自服务端的确认报文后，还需要向服务端最终确认（ACK），发送的报文首部中<font color='red'>确认位ACK=1，序号seq=x+1，确认号ack=y+1</font>（ACK报文可携带数据，若不携带数据则不消耗序号，下次发送报文序号仍旧是seq=x+1）；
5. 服务端B收到了客户端的确认，至此AB均进入`ESTABLISHED`（连接建立状态）。

#### 为什么是三次握手而不是两次或者四次？

- 三次就已经可以建立连接了，四次会浪费资源

- 第三次握手是为了防止服务端B突然收到了**已经失效的连接请求报文**而去打开错误连接。

  考虑到网络环境的问题，假设客户端在发送了一次连接请求报文后，因在某些网络节点滞留较长时间，迟迟没有收到来自服务端的确认报文，因此在超过了一个超时重传时间后，再次发起连接请求，这次连接成功建立...完成了任务后释放了连接，这时服务器才第一个连接请求报文，以为是客户端又发起的连接请求，于是确认连接，并初始化连接资源，如此造成了资源浪费。如果有第三次握手的话，客户端会略过服务器的确认报文，因此并不会打开本次连接。

#### 半连接队列

服务器在发送完确认连接报文（SYN+ACK）后进入`SYN_RCVD`状态，此时会将这种尚未完成状态的连接保存在一个半连接列队中，列队里其他项也全是类似这种还没有完全完成的连接。

在收到客户端的最终确认包（ACK）表示完成连接，或者超过了SYN_ACK的最大重传次数，都会将该半连接从队列中移除。

#### 利用TCP三次握手的洪泛攻击 SYN Flood

在服务端发送完确认连接报文（SYN+ACK）进入`SYN_RCVD`状态后，迟迟未收到客户端的最终确认报文（ACK），此时会不断再次发送确认连接报文，并会在一段时间内等待客户端发来的最终确认报文，这段时间长度称为`SYN Timeout`（30s~2min），若这段时间仍旧未收到则丢弃该未完成的连接。

SYN Flood攻击就利用服务器会等待一段时间，发起巨量的半连接而消耗服务端的资源（占满了半连接队列），最终导致服务端无法响应正常的连接请求。

- 解决方案
  1. 在客户端和服务器中间架设防火墙，客户端先跟防火墙建立三次握手连接后，防火墙再与服务端建立三次握手连接，此后CS通信会通过防火墙来转发数据。
  2. 缩短`SYN Timeout`...

### 2. TCP四次挥手

因为TCP连接是全双工通信，连接建立好后，客户端与服务端均为`ESTABLISHED`状态，故客户端和服务端均可主动发起关闭连接的请求。同时全双工带来的是TCP半关闭的性质，即关闭了自己发送数据的通道，但是仍旧可以接收数据。

<img src='tcp_handbye.png' width=70% />

#### 流程

1. 客户端A发出连接释放报文（FIN），其中首部 <font color='red'>终止位FIN=1，序号seq=u</font>，发送完成后客户端算是关闭了TCP连接，进入`FIN_WAIT_1`（终止等待1状态），等待服务端的确认；

2. 服务端B收到连接释放请求后，会发送ACK确认报文，<font color='red'>确认位ACK=1，序号seq=v，确认号ack=u+1</font>，表明服务端已经收到了连接关闭请求，服务端进入`CLOSE_WAIT`（等待关闭状态）。此时仍旧可以向客户端发送数据；

   > 此时TCP连接处于半关闭状态，客户端到服务端连接被关闭，即A可接受B数据，A不能向B发数据。

3. 客户端接收到服务端的确认报文后，进入`FIN_WAIT_2`（终止等待2状态）；

4. 待服务端发送完了数据，想要关闭连接了，会给客户端发送连接释放报文（FIN+ACK），首部 <font color='red'>终止位FIN=1，确认位ACK=1，序号seq=w，确认号ack=u+1</font>，这时服务器进入`LAST_ACK`（最后确认状态），等待客户端的确认；

5. 客户端收到连接释放报文后，类似于第二次挥手服务端的工作一样，会给服务端发送一个ACK确认报文，<font color='red'>确认位ACK=1，序号seq=u+1，确认号ack=w+1</font>，然后进入`TIME_WAIT`（时间等待状态）；

6. 服务端收到来自客户端的ACK报文后就会进入`CLOSED`（关闭状态）；

7. 客户端会等**2MSL**时长后，以确保服务端收到了ACK报文才从`TIME_WAIT`进入`CLOSED`（关闭状态）。

#### 为什么挥手次数需要四次？

前面有说过TCP连接是全双工通信，每次一个FIN报文加一个ACK报文一来一回才能关闭一个通道的连接，故需要需要两边都发送FIN报文再回复ACK报文才能保证两边都释放了连接。

#### 为什么要进入TIME_WAIT还要等2MSL才能进入CLOSED？

1. 确保最后一个ACK报文不丢失。

   假设因为网络环境原因，服务端没有收到最后一个ACK报文，则会重发连接释放报文，客户端在这段等待时间里收到了服务器新发来的释放连接报文，会再次重发最后一个ACK报文，保证服务端正常释放连接！

2. 保证本次连接中没有任何存活的报文。

   在`TIME_WAIT`状态下，客户端和服务端的端口不能使用，需要等到2MSL时间结束后才能继续使用。由于网络环境原因，客户端可能重传过连接请求报文，这类报文在连接释放后的2MSL时间内，就不会再次发起连接请求了。

   > MSL（Maximum Segment Lifetime，报文最大生存时间），在网络中超过这个时间的报文都将丢弃。

   

## 参考文献

[CS-Notes/notes/计算机网络-传输层]( [https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E4%BC%A0%E8%BE%93%E5%B1%82.md](https://github.com/CyC2018/CS-Notes/blob/master/notes/计算机网络 - 传输层.md) )